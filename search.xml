<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>css混合模式(blend-mode)</title>
      <link href="/blog/2020/08/29/css%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F-blend-mode/"/>
      <url>/blog/2020/08/29/css%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F-blend-mode/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天要说的是 <blend-mode> 其是一中 css 数据类型，用于描述当前元素重叠时，颜色应当如何呈现。它被用于 <code>background-blend-mode</code> 和 <code>mix-blend-mode</code> 属性。</p><p>当层重叠时，例如：同一元素设置多个背景图、父子元素的重叠。这时混合模式就是计算像素最终颜色值的方法。</p></blockquote><h2 id="background-blend-mode-属性"><a href="#background-blend-mode-属性" class="headerlink" title="background-blend-mode 属性"></a>background-blend-mode 属性</h2><p>该属性主要用于设置背景的混合模式，我们都知道背景颜色其实可以设置多个图片，或者多个图片加上单个纯颜色值，而这些图片与颜色值其实是层叠在一起的，通过这个属性我们可以将它们进行不同方式的融合，呈现出其他的颜色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid pink;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">200px</span> <span class="number">19px</span>/<span class="number">200px</span> <span class="built_in">url</span>(<span class="string">&quot;./meinv.jpg&quot;</span>) no-repeat, <span class="number">0px</span>/ cover <span class="built_in">url</span>(<span class="string">&quot;./bg.jpg&quot;</span>) pink;</span><br><span class="line">    <span class="attribute">background-blend-mode</span>: darken;</span><br><span class="line">    <span class="comment">/*mix-blend-mode: normal;*/</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下图：</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/image-20200829190933929_2020_08_29_19h_09m_43s_049ms_r5a7.png" alt="image-20200829190933929"></p><p>该属性是是一种更接近于 ps 能力的工具，需要相关专业的知识才能够好的进行调试，具体取值可以<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/blend-mode">参考这里</a>。</p><h2 id="mix-blend-mode-属性"><a href="#mix-blend-mode-属性" class="headerlink" title="mix-blend-mode 属性"></a>mix-blend-mode 属性</h2><p>该属性描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合。</p><p>使用该属性我们一般需要一种嵌套关系，我们可以将该属性设置在子元素上生成混合效果，具体取值可以<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mix-blend-mode">参考这里</a>。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 混合模式 </tag>
            
            <tag> blend-mode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几种取消Ajax请求的方法</title>
      <link href="/blog/2020/08/28/%E5%87%A0%E7%A7%8D%E5%8F%96%E6%B6%88Ajax%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/blog/2020/08/28/%E5%87%A0%E7%A7%8D%E5%8F%96%E6%B6%88Ajax%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="原生-Ajax-取消方式"><a href="#原生-Ajax-取消方式" class="headerlink" title="原生 Ajax 取消方式"></a>原生 Ajax 取消方式</h2><p>对于原生XHR对象来说，取消的ajax的关键是调用XHR对象的.abort()方法，请求被中断之后会触发 onabort 事件不会触发 error 事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ajax = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">ajax.open(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/api/sys/listTmallShop&quot;</span>);</span><br><span class="line">ajax.send(<span class="literal">null</span>);</span><br><span class="line">ajax.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ajax.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(ajax.response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ajax.onabort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;请求被中断&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 立即取消请求</span></span><br><span class="line">ajax.abort();</span><br></pre></td></tr></table></figure><p>通过 abort 方法取消的请求在浏览器端可以方便的看到取消的状态。</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/image-20200828230322026_2020_08_28_23h_03m_42s_566ms_r74b.png" alt="image-20200828230322026"></p><h2 id="jquery-取消方式"><a href="#jquery-取消方式" class="headerlink" title="jquery 取消方式"></a>jquery 取消方式</h2><p>由于 jquery 的 ajax 函数会返回一个原生的 xhr 对象所以可以通过这个对象调用原生的 abort 方法取消请求，取消之后会触发 error 事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jp = $.ajax(&#123;</span><br><span class="line">    type: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">    url: <span class="string">&quot;/api/sys/listTmallShop&quot;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        platform: <span class="string">&quot;TMALL&quot;</span>,</span><br><span class="line">        page: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;成功了&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;取消了&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">jp.abort();</span><br></pre></td></tr></table></figure><h2 id="axios-的取消方式"><a href="#axios-的取消方式" class="headerlink" title="axios 的取消方式"></a>axios 的取消方式</h2><blockquote><p>axios 的取消方式相对复杂一些，但从 API 来看他封装了太多东西，这是一种设计上的缺陷，吐槽完毕之后用还是照样用。无奈！</p></blockquote><p>axios的取消需要使用 CancelToken 获取取消令牌，并且用令牌标识单个请求，之后调用令牌的 cancel 即可取消</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">const</span> source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.post(<span class="string">&quot;/api/sys/listTmallShop&quot;</span>, <span class="literal">null</span>, &#123;</span><br><span class="line">    cancelToken: source.token</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">thrown</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (axios.isCancel(thrown)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;取消了&quot;</span>, thrown.message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">source.cancel(<span class="string">&quot;取消原因：老子愿意&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果多个请求可以多次执行 CancelToken.source() 拿到多个 token对象</p><p>除了以上的方式还有一种方式可以取消请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">let</span> cancel;</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// An executor function receives a cancel function as a parameter</span></span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancel the request</span></span><br><span class="line">cancel();</span><br></pre></td></tr></table></figure><p>经过测试 axios 立刻取消的请求是不在浏览器网络调试中显示的。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 网络 </tag>
            
            <tag> 取消ajax请求 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google是怎么优化v8垃圾回收效率的</title>
      <link href="/blog/2020/08/16/Google%E6%98%AF%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96v8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%95%88%E7%8E%87%E7%9A%84/"/>
      <url>/blog/2020/08/16/Google%E6%98%AF%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96v8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%95%88%E7%8E%87%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上节我们介绍了 V8 使用副垃圾回收器和主垃圾回收器来处理垃圾回收，这节课我们看看 V8 是如何优化垃圾回收器的执行效率的。</p></blockquote><p>由于 JavaScript 是运行在主线程之上的，因此，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿（Stop-The-World）</strong>。</p><p>一次完整的垃圾回收分为标记和清理两个阶段，垃圾数据标记之后，V8 会继续执行清理和整理操作，虽然主垃圾回收器和副垃圾回收器的处理方式稍微有些不同，但它们都是主线程上执行的，执行垃圾回收过程中，会暂停主线程上的其他任务，具体全停顿的执行效果如下图所示：</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/9004196c53f2f381a1321bcbc346fc23_2020_08_16_22h_32m_57s_015ms_r804.jpeg" alt="img"></p><p>可以看到，执行垃圾回收时会占用主线程的时间，如果在执行垃圾回收的过程中，垃圾回收器占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如，页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行，造成页面的**卡顿 (Jank)**，用户体验不佳。</p><p>为了解决全停顿而造成的用户体验的问题，V8 团队经过了很多年的努力，向现有的垃圾回收器添加并行、并发和增量等垃圾回收技术，并且也已经取得了一些成效。这些技术主要是从两方面来解决垃圾回收效率问题的：</p><p>第一，<strong>将一个完整的垃圾回收的任务拆分成多个小的任务</strong>，这样就消灭了单个长的垃圾回收任务；</p><p>第二，<strong>将标记对象、移动对象等任务转移到后台线程进行</strong>，这会大大减少主线程暂停的时间，改善页面卡顿的问题，让动画、滚动和用户交互更加流畅。</p><p>接下来，我们就来深入分析下，V8 是怎么向现有的垃圾回收器添加并行、并发和增量等技术，来提升垃圾回收执行效率的。</p><h2 id="并行回收"><a href="#并行回收" class="headerlink" title="并行回收"></a>并行回收</h2><p>既然执行一次完整的垃圾回收过程比较耗时，那么解决效率问题，第一个思路就是主线程在执行垃圾回收的任务时，引入多个辅助线程来并行处理，这样就会加速垃圾回收的执行速度，因此 V8 团队引入了并行回收机制。</p><p>所谓并行回收，是指垃圾回收器在主线程上执行的过程中，还会开启多个协助线程，同时执行同样的回收工作，其工作模式如下图所示：</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/00537bdadac433a57c77c56c5cc33c1f_2020_08_16_22h_33m_04s_189ms_r07f.jpeg" alt="img"></p><p>采用并行回收时，垃圾回收所消耗的时间，等于总体辅助线程所消耗的时间（辅助线程数量乘以单个线程所消耗的时间），再加上一些同步开销的时间。这种方式比较简单，因为在执行垃圾标记的过程中，主线程并不会同时执行 JavaScript 代码，因此 JavaScript 代码也不会改变回收的过程。所以我们可以假定内存状态是静态的，因此只要确保同时只有一个协助线程在访问对象就好了。</p><p>V8 的副垃圾回收器所采用的就是并行策略，它在执行垃圾回收的过程中，启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域。由于数据的地址发生了改变，所以还需要同步更新引用这些对象的指针。</p><h2 id="增量回收"><a href="#增量回收" class="headerlink" title="增量回收"></a>增量回收</h2><p>虽然并行策略能增加垃圾回收的效率，能够很好地优化副垃圾回收器，但是这<strong>仍然是一种全停顿</strong>的垃圾回收方式，在主线程执行回收工作的时候才会开启辅助线程，这依然还会存在效率问题。比如老生代存放的都是一些大的对象，如 window、DOM 这种，完整执行老生代的垃圾回收，时间依然会很久。这些大的对象都是主垃圾回收器的，所以在 2011 年，V8 从又引入了增量标记的方式，我们把这种垃圾回收的方式称为<strong>谓增量式垃圾回收</strong>。</p><p>所谓增量式垃圾回收，是指垃圾收集器将标记工作分解为更小的块，并且穿插在主线程不同的任务之间执行。采用增量垃圾回收时，垃圾回收器没有必要一次执行完整的垃圾回收过程，每次执行的只是整个垃圾回收过程中的一小部分工作，具体流程你可以参看下图：</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/be18e6dc6c93e761a37d50aed48f246f_2020_08_16_22h_33m_08s_813ms_r63e.jpeg" alt="img"></p><p>增量标记的算法，比全停顿的算法要稍微复杂，这主要是因为<strong>增量回收是并发的（concurrent）</strong>，要实现增量执行，需要满足两点要求：</p><p>垃圾回收可以被随时暂停和重启，暂停时需要保存当时的扫描结果，等下一波垃圾回收来了之后，才能继续启动。</p><p>在暂停期间，被标记好的垃圾数据如果被 JavaScript 代码修改了，那么垃圾回收器需要能够正确地处理。</p><p>我们先来看看第一点，V8 是如何实现垃圾回收器的暂停和恢复执行的。</p><p>这里我们需要知道，在没有采用增量算法之前，V8 使用黑色和白色来标记数据。在执行一次完整的垃圾回收之前，垃圾回收器会将所有的数据设置为白色，用来表示这些数据还没有被标记，然后垃圾回收器在会从 GC Roots 出发，将所有能访问到的数据标记为黑色。遍历结束之后，被标记为黑色的数据就是活动数据，那些白色数据就是垃圾数据。如下图所示：</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/e1409de965aaab9bbf401249b1e02d0c_2020_08_16_22h_33m_16s_711ms_r58c.jpeg" alt="img"></p><p>如果内存中的数据只有两种状态，非黑即白，那么当你暂停了当前的垃圾回收器之后，再次恢复垃圾回收器，那么垃圾回收器就不知道从哪个位置继续开始执行了。</p><p>比如垃圾回收器执行了一小段增量回收后，被 V8 暂停了，然后主线程执行了一段 JavaScript 代码，然后垃圾回收器又被恢复了，那么恢复时内存状态就如下图所示：</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/2cd1ef856522ad0c8176c60b75e63c4d_2020_08_16_22h_33m_20s_029ms_r84b.jpeg" alt="img"></p><p>那么，当垃圾回收器再次被启动的时候，它到底是从 A 节点开始标记，还是从 B 节点开始执行标注过程呢？因为没有其他额外的信息，所以垃圾回收器也不知道该如何处理了。</p><p>为了解决这个问题，V8 采用了<strong>三色标记法，</strong>除了黑色和白色，还额外引入了灰色：</p><p>黑色表示这个节点被 GC Root 引用到了，而且该节点的子节点都已经标记完成了 ;</p><p>灰色表示这个节点被 GC Root 引用到，但子节点还没被垃圾回收器标记处理，也表明目前正在处理这个节点；</p><p>白色表示这个节点没有被访问到，如果在本轮遍历结束时还是白色，那么这块数据就会被收回。</p><p>引入灰色标记之后，垃圾回收器就可以依据当前内存中有没有灰色节点，来判断整个标记是否完成，如果没有灰色节点了，就可以进行清理工作了。如果还有灰色标记，当下次恢复垃圾回收器时，便从灰色的节点开始继续执行。</p><p>因此采用三色标记，可以很好地支持增量式垃圾回收。</p><p>接下来，我们再来分析下，标记好的垃圾数据被 JavaScript 修改了，V8 是如何处理的。我们看下面这样的一个例子：</p><p>window.a = Object()</p><p>window.a.b = Object()</p><p>window.a.b.c=Object() </p><p>执行到这段代码时，垃圾回收器标记的结果如下图所示：</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/19bbfb35d274064b253814b58413bc17_2020_08_16_22h_33m_23s_664ms_rdea.jpeg" alt="img"></p><p>然后又执行了另外一个代码，这段代码如下所示：</p><p>window.a.b = Object() //d</p><p>执行完之后，垃圾回收器又恢复执行了增量标记过程，由于 b 重新指向了 d 对象，所以 b 和 c 对象的连接就断开了。这时候代码的应用如下图所示：</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/759f6a8105d64d3aebdc16f81a2b5e15_2020_08_16_22h_33m_27s_295ms_r9b8.jpeg" alt="img"></p><p>这就说明一个问题，当垃圾回收器将某个节点标记成了黑色，然后这个黑色的节点被续上了一个白色节点，那么垃圾回收器不会再次将这个白色节点标记为黑色节点了，因为它已经走过这个路径了。</p><p>但是这个新的白色节点的确被引用了，所以我们还是需要想办法将其标记为黑色。</p><p>为了解决这个问题，增量垃圾回收器添加了一个约束条件：<strong>不能让黑色节点指向白色节点</strong>。</p><p>通常我们使用<strong>写屏障 (Write-barrier) 机制</strong>实现这个约束条件，也就是说，当发生了黑色的节点引用了白色的节点，写屏障机制会强制将被引用的白色节点变成灰色的，这样就保证了黑色节点不能指向白色节点的约束条件。这个方法也被称为<strong>强三色不变性</strong>，它保证了垃圾回收器能够正确地回收数据，因为在标记结束时的所有白色对象，对于垃圾回收器来说，都是不可到达的，可以安全释放。</p><p>所以在 V8 中，每次执行如 window.a.b = value的写操作之后，V8 会插入写屏障代码，强制将 value 这块内存标记为灰色。</p><h2 id="并发-concurrent-回收"><a href="#并发-concurrent-回收" class="headerlink" title="并发 (concurrent) 回收"></a>并发 (concurrent) 回收</h2><p>虽然通过<strong>三色标记法和写屏障</strong>机制可以很好地实现增量垃圾回收，但是由于这些操作都是在主线程上执行的，如果主线程繁忙的时候，增量垃圾回收操作依然会增加降低主线程处理任务的**吞吐量 (throughput)**。</p><p>结合并行回收可以将一些任务分配给辅助线程，但是并行回收依然会阻塞主线程，那么，有没有办法在不阻塞主线程的情况下，执行垃圾回收操作呢？</p><p>还真有，这就是我们要来重点研究的<strong>并发回收机制</strong>了。</p><p><strong>所谓并发回收，是指主线程在执行 JavaScript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作。</strong>并发标记的流程大致如下图所示：</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/157052aa087c840f5f58a7708f30bdc2_2020_08_16_22h_33m_30s_665ms_r81c.jpeg" alt="img"></p><p>并发回收的优势非常明显，主线程不会被挂起，JavaScript 可以自由地执行 ，在执行的同时，辅助线程可以执行垃圾回收操作。</p><p>但是并发回收却是这三种技术中最难的一种，这主要由以下两个原因导致的：</p><p>第一，当主线程执行 JavaScript 时，堆中的内容随时都有可能发生变化，从而使得辅助线程之前做的工作完全无效；</p><p>第二，主线程和辅助线程极有可能在同一时间去更改同一个对象，这就需要额外实现读写锁的一些功能了。</p><p>尽管并行回收要额外解决以上两个问题，但是权衡利弊，并行回收这种方式的效率还是远高于其他方式的。</p><p>不过，这三种技术在实际使用中，并不是单独的存在，通常会将其融合在一起使用，V8 的主垃圾回收器就融合了这三种机制，来实现垃圾回收，那它具体是怎么工作的呢？你可以先看下图：</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/7b8b901cb2eb575bb8907e1ad7dc1842_2020_08_16_22h_33m_34s_111ms_rf61.jpeg" alt="img"></p><p>可以看出来，主垃圾回收器同时采用了这三种策略：</p><p>首先主垃圾回收器主要使用并发标记，我们可以看到，在主线程执行 JavaScript，辅助线程就开始执行标记操作了，所以说标记是在辅助线程中完成的。</p><p>标记完成之后，再执行并行清理操作。主线程在执行清理操作时，多个辅助线程也在执行清理操作。</p><p>另外，主垃圾回收器还采用了增量标记的方式，清理的任务会穿插在各种 JavaScript 任务之间执行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>V8 最开始的垃圾回收器有两个特点，第一个是垃圾回收在主线程上执行，第二个特点是一次执行一个完整的垃圾回收流程。</p><p>由于这两个原因，很容易造成主线程卡顿，所以 V8 采用了很多优化执行效率的方案。</p><p>第一个方案是并行回收，在执行一个完整的垃圾回收过程中，垃圾回收器会使用多个辅助线程来并行执行垃圾回收。</p><p>第二个方案是增量式垃圾回收，垃圾回收器将标记工作分解为更小的块，并且穿插在主线程不同的任务之间执行。采用增量垃圾回收时，垃圾回收器没有必要一次执行完整的垃圾回收过程，每次执行的只是整个垃圾回收过程中的一小部分工作。</p><p>第三个方案是并发回收，回收线程在执行 JavaScript 的过程，辅助线程能够在后台完成的执行垃圾回收的操作。</p><p>主垃圾回收器就综合采用了所有的方案，副垃圾回收器也采用了部分方案。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google V8引擎 垃圾回收机制</title>
      <link href="/blog/2020/08/16/Google-V8%E5%BC%95%E6%93%8E-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/blog/2020/08/16/Google-V8%E5%BC%95%E6%93%8E-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们都知道，JavaScript 是一门自动垃圾回收的语言，也就是说，我们不需要去手动回收垃圾数据，这一切都交给 V8 的垃圾回收器来完成。V8 为了更高效地回收垃圾，引入了两个垃圾回收器，它们分别针对着不同的场景。</p><p>那这两个回收器究竟是如何工作的呢，这节课我们就来分析这个问题。</p></blockquote><h2 id="垃圾数据是怎么产生的？"><a href="#垃圾数据是怎么产生的？" class="headerlink" title="垃圾数据是怎么产生的？"></a>垃圾数据是怎么产生的？</h2><p>首先，我们看看垃圾数据是怎么产生的。</p><p>无论是使用什么语言，我们都会频繁地使用数据，这些数据会被存放到栈和堆中，通常的方式是在内存中创建一块空间，使用这块空间，在不需要的时候回收这块空间。</p><p>比如下面这样一句代码：</p><p>window.test = new Object()</p><p>window.test.a = new Uint16Array(100)</p><p>当 JavaScript 执行这段代码的时候，会先为 window 对象添加一个 test 属性，并在堆中创建了一个空对象，并将该对象的地址指向了 window.test 属性。随后又创建一个大小为 100 的数组，并将属性地址指向了 test.a 的属性值。此时的内存布局图如下所示：</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/42b70203c6da641831d778ce08a7a5b1_2020_08_16_21h_59m_10s_888ms_r13a.jpeg" alt="img"></p><p>我们可以看到，栈中保存了指向 window 对象的指针，通过栈中 window 的地址，我们可以到达 window 对象，通过 window 对象可以到达 test 对象，通过 test 对象还可以到达 a 对象。</p><p>如果此时，我将另外一个对象赋给了 a 属性，代码如下所示：</p><p>window.test.a = new Object()</p><p>那么此时的内存布局如下所示：</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/9c44e8bb2a75a8da72877c8a192967dc_2020_08_16_21h_59m_38s_519ms_r509.jpeg" alt="img"></p><p>我们可以看到，a 属性之前是指向堆中数组对象的，现在已经指向了另外一个空对象，那么此时堆中的数组对象就成为了垃圾数据，因为我们无法从一个根对象遍历到这个 Array 对象。</p><p>不过，你不用担心这个数组对象会一直占用内存空间，因为 V8 虚拟机中的垃圾回收器会帮你自动清理。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>那么垃圾回收是怎么实现的呢？大致可以分为以下几个步骤：</p><p>第一步，通过 GC Root 标记空间中<strong>活动对象</strong>和<strong>非活动对象</strong>。</p><p>目前 V8 采用的<strong>可访问性（reachability）算法</strong>来判断堆中的对象是否是活动对象。具体地讲，这个算法是将一些 <strong>GC Root</strong> 作为初始存活的对象的集合，从 GC Roots 对象出发，遍历 GC Root 中的所有对象：</p><p>通过 GC Root 遍历到的对象，我们就认为该对象是<strong>可访问的（reachable）</strong>，那么必须保证这些对象应该在内存中保留，我们也称可访问的对象为活动对象；</p><p>通过 GC Roots 没有遍历到的对象，则是<strong>不可访问的（unreachable）</strong>，那么这些不可访问的对象就可能被回收，我们称不可访问的对象为非活动对象。</p><p>在浏览器环境中，GC Root 有很多，通常包括了以下几种 (但是不止于这几种)：</p><p>全局的 window 对象（位于每个 iframe 中）；</p><p>文档 DOM 树，由可以通过遍历文档到达的所有原生 DOM 节点组成；</p><p>存放栈上变量。</p><p>第二步，回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p><p>第三步，做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为<strong>内存碎片</strong>。当内存中出现了大量的内存碎片之后，如果需要分配较大的连续内存时，就有可能出现内存不足的情况，所以最后一步需要整理这些内存碎片。但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。</p><p>以上就是大致的垃圾回收的流程。目前 V8 采用了两个垃圾回收器，<strong>主垃圾回收器 -Major GC 和副垃圾回收器 -Minor GC (Scavenger)**。V8 之所以使用了两个垃圾回收器，主要是受到了</strong>代际假说（The Generational Hypothesis）**的影响。</p><p>代际假说是垃圾回收领域中一个重要的术语，它有以下两个特点：</p><p>第一个是大部分对象都是“朝生夕死”的，也就是说大部分对象在内存中存活的时间很短，比如函数内部声明的变量，或者块级作用域中的变量，当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。因此这一类对象一经分配内存，很快就变得不可访问；</p><p>第二个是不死的对象，会活得更久，比如全局的 window、DOM、Web API 等对象。</p><p>其实这两个特点不仅仅适用于 JavaScript，同样适用于大多数的编程语言，如 Java、Python 等。</p><p>V8 的垃圾回收策略，就是建立在该假说的基础之上的。接下来，我们来分析下 V8 是如何实现垃圾回收的。</p><p>如果我们只使用一个垃圾回收器，在优化大多数新对象的同时，就很难优化到那些老对象，因此你需要权衡各种场景，根据对象生存周期的不同，而使用不同的算法，以便达到最好的效果。</p><p>所以，在 V8 中，会把堆分为新生代和老生代两个区域，<strong>新生代中存放的是生存时间短的对象，老生代中存放生存时间久的对象</strong>。</p><p>新生代通常只支持 1～8M 的容量，而老生代支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p><p><strong>副垃圾回收器 -Minor GC (Scavenger)，主要负责新生代的垃圾回收。</strong></p><p><strong>主垃圾回收器 -Major GC，主要负责老生代的垃圾回收。</strong></p><h2 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h2><p>副垃圾回收器主要负责新生代的垃圾回收。通常情况下，大多数小的对象都会被分配到新生代，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。</p><p>新生代中的垃圾数据用 <strong>Scavenge 算法</strong>来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是<strong>对象区域 (from-space)**，一半是</strong>空闲区域 (to-space)**，如下图所示：</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/75329eceafd88573097f8d073430bc9d_2020_08_16_21h_59m_48s_792ms_r03a.jpeg" alt="img"></p><p>新生区要划分为对象区域和空闲区域</p><p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p><p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段。副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/12519a0d1f2484cd24297e821f2f1887_2020_08_16_21h_59m_54s_259ms_r7fe.jpeg" alt="img"></p><p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时，<strong>这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去</strong>。</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/797db43b27c8a6add1ffa540910c7ebd_2020_08_16_21h_59m_59s_549ms_r420.jpeg" alt="img"></p><p>不过，副垃圾回收器每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域，复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以<strong>为了执行效率，一般新生区的空间会被设置得比较小</strong>。</p><p>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域，副垃圾回收器一旦监控对象装满了，便执行垃圾回收。同时，副垃圾回收器还会采用<strong>对象晋升策略</strong>，也就是移动那些经过两次垃圾回收依然还存活的对象到老生代中。</p><h2 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h2><p>主垃圾回收器主要负责老生代中的垃圾回收。除了新生代中晋升的对象，一些大的对象会直接被分配到老生代里。因此，老生代中的对象有两个特点：</p><p>一个是对象占用空间大；</p><p>另一个是对象存活时间长。</p><p>由于老生代的对象比较大，若要在老生代中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。所以，主垃圾回收器是采用<strong>标记 - 清除（Mark-Sweep）</strong>的算法进行垃圾回收的。</p><p>那么，标记 - 清除算法是如何工作的呢？</p><p><strong>首先是标记过程阶段。</strong>标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</p><p><strong>接下来就是垃圾的清除过程。</strong>它和副垃圾回收器的垃圾清除过程完全不同，主垃圾回收器会直接将标记为垃圾的数据清理掉。</p><p>你可以理解这个过程是清除掉下图中红色标记数据的过程，你可参考下图大致理解下其清除过程：</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/c70cdb85c0b656061e4cc420efdaf59b_2020_08_16_22h_00m_05s_535ms_r7dd.jpeg" alt="img"></p><p>标记清除过程</p><p>对垃圾数据进行标记，然后清除，这就是<strong>标记 - 清除算法</strong>，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又引入了另外一种算法——<strong>标记 - 整理（Mark-Compact）</strong>。</p><p>这个算法的标记过程仍然与标记 - 清除算法里的是一样的，先标记可回收对象，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉这一端之外的内存。你可以参考下图：</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/6a558a6731fd68757e1a43c1dbc27ed8_2020_08_16_22h_00m_09s_185ms_r9be.jpeg" alt="img"></p><p>标记整理过程</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天，我们先分析了什么是垃圾数据，从“GC Roots”对象出发，遍历 GC Root 中的所有对象，如果通过 GC Roots 没有遍历到的对象，则这些对象便是垃圾数据。V8 会有专门的垃圾回收器来回收这些垃圾数据。</p><p>V8 依据代际假说，将堆内存划分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放生存时间久的对象。为了提升垃圾回收的效率，V8 设置了两个垃圾回收器，主垃圾回收器和副垃圾回收器。主垃圾回收器负责收集老生代中的垃圾数据，副垃圾回收器负责收集新生代中的垃圾数据。</p><p>副垃圾回收器采用了 <strong>Scavenge 算法</strong>，是把新生代空间对半划分为两个区域，一半是<strong>对象区域</strong>，一半是<strong>空闲区域</strong>。新的数据都分配在对象区域，等待对象区域快分配满的时候，垃圾回收器便执行垃圾回收操作，之后将存活的对象从对象区域拷贝到空闲区域，并将两个区域互换。主垃圾回收器回收器主要负责老生代中的垃圾数据的回收操作，会经历标记、清除和整理过程。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 底层原理 </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM监控MutationObserver</title>
      <link href="/blog/2020/08/10/DOM%E7%9B%91%E6%8E%A7MutationObserver/"/>
      <url>/blog/2020/08/10/DOM%E7%9B%91%E6%8E%A7MutationObserver/</url>
      
        <content type="html"><![CDATA[<p><strong><code>MutationObserver </code>接口提供了监视DOM树更改的能力，是旧的 <code>Mutation</code> 的替代品</strong></p><p>使用方式：通过 <code>MutationObserver</code>构造函数创建对象 <code>ob</code>，该对象下有以下可用方法</p><ul><li>observe(dom对象,option) ：配置<code>MutationObserver</code>在DOM更改匹配给定选项时，通过其回调函数开始接受通知</li><li>disconnect()：取消监控</li><li>takeRecords()：从<code>MutationObserver</code>的通知队列中删除所有待处理的通知，并将它们返回到 <code>MutationRecord</code>对象的新<code>Array</code>中</li></ul><p><strong>一个简单的示例</strong></p><p>html部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点击按钮取消监控<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>javascript部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">,    <span class="keyword">let</span> container = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.container&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.btn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;监控已经取消&#x27;</span>);</span><br><span class="line">        observer.disconnect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;回调函数参数&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(callback);</span><br><span class="line"></span><br><span class="line">    observer.observe(container,&#123;</span><br><span class="line">        attributes: <span class="literal">true</span> <span class="comment">// 指定元素属性改变的时候触发回调</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p><strong><code>详解 observe disconnect takeRecords</code></strong></p><ul><li><p>observe 方法主要指定要监控哪些 DOM 的变化作为第一个参数传入，和要监控哪些地方，使用一个对象描述并作为第二个参数传入</p><ul><li><p>参数一: 要观察的 DOM 或者要观察的所有子节点的公共根节点</p><ul><li>参数二：一个可选的 <code>MutationObserverInit</code>对象，此对象的配置项描述了 DOM 的哪些变化要被监控，注意：<code>childList</code>，<code>attributes</code> 或者 <code>characterData</code> 三个属性之中，至少有一个必须为 <code>true</code>，否则会抛出 <code>TypeError</code> 异常，实际有<code>attributeFilter</code>也行</li></ul></li><li><p><code>MutationObserverInit 对象属性</code></p><table><thead><tr><th>属性</th><th align="left">描述</th></tr></thead><tbody><tr><td>attributeFilter</td><td align="left">要监视的特定属性名称的数组。如果未包含此属性，则对所有属性的更改都会触发变动通知。无默认值。</td></tr><tr><td>attributeOldValue</td><td align="left">当监视节点的属性改动时，将此属性设为 <code>true</code> 将记录任何有改动的属性的上一个值。有关观察属性更改和值记录的详细信息，详见<a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver#Monitoring_attribute_values">Monitoring attribute values</a> in <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">MutationObserver</a>。无默认值。</td></tr><tr><td>attributes</td><td align="left">设为 <code>true</code> 以观察受监视元素的属性值变更。默认值为 <code>false</code>。</td></tr><tr><td>characterData</td><td align="left">设为 <code>true</code> 以监视指定目标节点或子节点树中节点所包含的字符数据的变化。无默认值。在监控该类值的时候，传入observe的第一个参数应该是 textNode 而非 element ，不然就需要配合 subtree 使用</td></tr><tr><td>characterDataOldValue</td><td align="left">设为 <code>true</code> 以在文本在受监视节点上发生更改时记录节点文本的先前值。详情及例子，请查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver#Monitoring_text_content_changes">Monitoring text content changes</a> in <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver">MutationObserver</a>。无默认值。</td></tr><tr><td>childList</td><td align="left">设为 <code>true</code> 以监视目标节点（如果 <code>subtree</code> 为 <code>true</code>，则包含子孙节点）添加或删除新的子节点。默认值为 <code>false</code>。</td></tr><tr><td>subtree</td><td align="left">设为 <code>true</code> 以将监视范围扩展至目标节点整个节点树中的所有节点。<code>MutationObserverInit</code> 的其他值也会作用于此子树下的所有节点，而不仅仅只作用于目标节点。默认值为 <code>false</code>。</td></tr></tbody></table></li><li><p>重复的 observe 调用后面会覆盖前面，前提是第一个参数是相同的，实质上只覆盖了要监控的类型也就是第二个参数</p></li></ul></li><li><p>disconnect 方法移除监控，如果某个元素从 dom 树中移除那么 MutationObserve 将同样被删除</p></li><li><p>takeRecords 方法返回已检测到但尚未由观察者的回调函数处理的所有匹配DOM更改的列表，使变更队列保持为空。 此方法最常见的使用场景是在断开观察者之前立即获取所有未处理的更改记录，以便在停止观察者时可以处理任何未处理的更改。该方法通常是程序级别的监控，例如设置监控之后立马修改然后调用该方法就可以获取到信息</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(container.childNodes);</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">observer.observe(container.childNodes[<span class="number">0</span>], &#123;</span><br><span class="line">    <span class="comment">// attributes: true,</span></span><br><span class="line">    characterData: <span class="literal">true</span>,</span><br><span class="line">    characterDataOldValue: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// childList: true,</span></span><br><span class="line">    <span class="comment">// subtree: true</span></span><br><span class="line">    <span class="comment">// attributeFilter: [&quot;class&quot;,&quot;data-username&quot;],</span></span><br><span class="line">    <span class="comment">// attributeOldValue: true</span></span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line">container.childNodes[<span class="number">0</span>].textContent = <span class="string">&quot;哈哈哈123&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(observer.takeRecords());</span><br></pre></td></tr></table></figure></li></ul><p><strong>监控到变化之后获取信息：</strong></p><p>只监控变化没有用，重要的是我们要知道哪里变了，通常我们可以拿到变化前的老值，新值可以通过具体dom对象获取，关于信息回调函数参数中的 MutationRecord 对象很重要</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>MutationRecord.type</td><td>如果是属性变化，则返回 <code>&quot;attributes&quot;</code>；<br/>如果是 <code>characterData</code> 节点变化，则返回 <code>&quot;characterData&quot;</code>；<br/>如果是子节点树 <code>childList</code> 变化，则返回 <code>&quot;childList&quot;</code>。</td></tr><tr><td>MutationRecord.target</td><td>根据 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationRecord/type"><code>MutationRecord.type</code></a>，返回变化所影响的节点。<br/>对于属性 <code>attributes</code> 变化，返回属性变化的节点。<br/>对于 <code>characterData</code> 变化，返回 <code>characterData</code> 节点。<br/>对于子节点树 <code>childList</code> 变化，返回子节点变化的节点。</td></tr><tr><td>MutationRecord.addedNodes</td><td>返回被添加的节点。<br/>如果没有节点被添加，则该属性将是一个空的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/NodeList"><code>NodeList</code></a>。</td></tr><tr><td>MutationRecord.removedNodes</td><td>返回被移除的节点。<br/>如果没有节点被移除，则该属性将是一个空的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/NodeList"><code>NodeList</code></a>。</td></tr><tr><td>MutationRecord.previousSibling</td><td>返回被添加或移除的节点之前的兄弟节点，或者 <code>null</code>。</td></tr><tr><td>MutationRecord.nextSibling</td><td>返回被添加或移除的节点之后的兄弟节点，或者 <code>null</code>。</td></tr><tr><td>MutationRecord.attributeName</td><td>返回被修改的属性的属性名，或者 <code>null</code>。</td></tr><tr><td>MutationRecord.attributeNamespace</td><td>返回被修改属性的命名空间，或者 <code>null</code>。</td></tr><tr><td>MutationRecord.oldValue</td><td>返回值取决于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationRecord/type"><code>MutationRecord.type</code></a>。 对于属性 <code>attributes</code> 变化，返回变化之前的属性值。 对于 <code>characterData</code> 变化，返回变化之前的数据。 对于子节点树 <code>childList</code> 变化，返回 <code>null</code>。<br />注意，如果要让这个属性起作用，在相应的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserverInit">MutationObserverInit</a> 参数的 <code>MutationObserver</code> <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/observe">observe</a> 方法中，<code>attributeOldValue</code> 或者 <code>characterDataOldValue</code> 必须设置为 <code>true</code>。</td></tr></tbody></table><p><strong>特别注意：</strong>所有被监控到的更改，其记录的 target 信息都是具体被更改的那个节点对象，如果被更改的是 文本 那么 target 就是一个文本节点。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么有钱人不娶美女</title>
      <link href="/blog/2019/09/14/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E9%92%B1%E4%BA%BA%E4%B8%8D%E5%A8%B6%E7%BE%8E%E5%A5%B3/"/>
      <url>/blog/2019/09/14/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E9%92%B1%E4%BA%BA%E4%B8%8D%E5%A8%B6%E7%BE%8E%E5%A5%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载文章，从金融角度分析问题，仅供参考！</p></blockquote><p>一个年轻漂亮的美国女孩在美国一家大型网上论坛金融版上发表了这样一个问题帖：我怎样才能嫁给有钱人？<br>　　“我下面要说的都是心里话。本人25岁，非常漂亮，是那种让人惊艳的美，谈吐文雅，有品位，想嫁给年薪50万美元的人。你也许会说我贪心，但在纽约年薪100万才算是中产，本人的要求其实不高。<br>　　这个版上有没有年薪超过50万的人？你们都结婚了吗？我想请教各位一个问题—怎样才能嫁给你们这样的有钱人？我约会过的人中，最有钱的年薪25万，这似乎就是我的上限。要住进纽约中心公园以西的高尚住宅区，年薪25万远远不够。所以我是来诚心诚意请教的。有几个具体的问题：一、单身富豪一般都在哪里消磨时光？（请列出酒吧、饭店、健身房的名字和详细地址。）二、我应该把目标定在哪个年龄段？三、为什么有些富豪的妻子看起来相貌平平？我见过有些女孩，长相如同白开水，毫无吸引人的地方，但她们却能嫁入豪门。而吧台里那些迷人的美女却运气不佳。四、你们怎么决定谁能做妻子，谁只能做女朋友？(我现在的目标是结婚。)“——波尔斯女士<br>　　下面是一个华尔街金融家的回帖：<br>　　“亲爱的波尔斯：我怀着极大的兴趣看完了贵帖，相信不少女士也有跟你类似的疑问。让我以一个投资专家的身份，对你的处境做一分析。我年薪超过50万，符合你的择偶标准，所以请相信我并不是在浪费大家的时间。<br>　　从生意人的角度来看，跟你结婚是个糟糕的经营决策，道理再明白不过，请听我解释。抛开细枝末节，你所说的其实是一笔简单的“财”“貌”交易：甲方提供美丽的外表，乙方出钱，公平交易，童叟无欺。但是，这里有个致命的问题，你的美貌会消逝，但我的钱却不会无缘无故减少。事实上，我的收入很可能会逐年递增，但你不可能一年比一年漂亮。<br>　　因此，从经济学的角度讲，我是增值资产，你是贬值资产，不但贬值，而且是加速贬值！你现在25岁，在未来的五年里，你仍可以保持窈窕的身段，俏丽的容貌，虽然每年略有退步。但美貌消逝的速度会越来越快，如果它是你仅有的资产，十年以后，你的价值堪忧。<br>　　用华尔街术语说，每笔交易都是一个仓位，跟你交往属于“交易仓位”（tradingposition），一但价值下跌就要立即抛售，而不宜长期持有——也就是你想要的婚姻。听起来很残忍，但对一件会加速贬值的物资，明智的选择是租赁，而不是购入，年薪能超过50万的人，当然都不是傻瓜，因此我们只会跟你交往，但不会跟你结婚。所以我劝你不要苦苦寻找嫁给有钱人的秘方。顺便说一句，你倒可以想办法把自己变成年薪50万的人，这比碰到一个有钱的傻瓜的胜算要大。<br>　　希望我的回帖能对你有帮助。如果你对“租赁”感兴趣，请跟我联系。”——罗波坎贝尔（J.P.摩根银行多种产业投资顾问）<br>　　<br>　　<br>　　<br>　　这个是转自美国论坛的，英文原帖是：<br>　　What am I doing wrong?<br>　　<br>　　Okay, I’m tired of beating around the bush. I’m a beautiful (spectacularly beautiful) 25 year old girl. I’m articulate and classy. I’m not from New York . I’m looking to get married to a guy who makes at least half a million a year. I know how that sounds, but keep in mind that a million a year is middle class in New York City, so I don’t think I’m overreaching at all.<br>　　Are there any guys who make 500K or more on this board? Any wives? Could you send me some tips? I dated a business man who makes average around 200 - 250. But that’s where I seem to hit a roadblock. 250,000 won’t get me to central park west. I know a woman in my yoga class who was married to an investment banker and lives in Tribeca, and she’s not as pretty as I am, nor is she a great genius. So what is she doing right? How do I get to her level?<br>　　Here are my questions specifically:</p><p>　　- Where do you single rich men hang out? Give me specifics- bars, restaurants, gyms<br>　　- What are you looking for in a mate? Be honest guys, you won’t hurt my feelings<br>　　- Is there an age range I should be targeting (I’m 25)?<br>　　- Why are some of the women living lavish lifestyles on the upper east side so plain? I’ve seen really ‘plain jane’ boring types who have nothing to offer married to incredibly wealthy guys. I’ve seen drop dead gorgeous girls in singles bars in the east village. What’s the story there?- Jobs I should look out for? Everyone knows - lawyer, investment banker, doctor. How much do those guys really make? And where do they hang out? Where do the hedge fund guys hang out?- How you decide marriage vs. just a girlfriend? I am looking for MARRIAGE ONLYPlease hold your insults - I’m putting myself out there in an honest way. Most beautiful women are superficial; at least I’m being up front about it. I wouldn’t be searching for these kind of guys if I wasn’t able to match them - in looks, culture, sophistication, and keeping a nice home and hearth.<br>　　it’s NOT ok to contact this poster with services or other commercial interests<br>　　Craig’s List PostingID:</p><hr><p>　　THE ANSWER<br>　　Dear Pers-:<br>　　I read your posting with great interest and have thought meaningfully about your dilemma. I offer the following analysis of your predicament.<br>　　Firstly, I’m not wasting your time, I qualify as a guy who fits your bill; that is I make more than $500K per year. That said here’s how I see it.<br>　　Your offer, from the prospective of a guy like me, is plain and simple a crappy business deal. Here’s why. Cutting through all the B.S., what you suggest is a simple trade: you bring your looks to the party and I bring my money. Fine, simple. But here’s the rub, your looks will fade and my money will likely continue into perpetuity…in fact, it is very likely that my income increases but it is an absolute certainty that you won’t be getting any more beautiful!<br>　　So, in economic terms you are a depreciating asset and I am an earning asset . Not only are you a depreciating asset, your depreciation accelerates! Let me explain, you’re 25 now and will likely stay pretty hot for the next 5 years, but less so each year. Then the fade begins in earnest. By 35 stick a fork in you!<br>　　So in Wall Street terms, we would call you a trading position, not a buy and hold…hence the rub…marriage. It doesn’t make good business sense to “buy you” (which is what you’re asking) so I’d rather lease. In case you think I’m being cruel, I would say the following. If my money were to go away, so would you, so when your beauty fades I need an out. It’s as simple as that. So a deal that makes sense is dating, not marriage.<br>　　Separately, I was taught early in my career about efficient markets. So, I wonder why a girl as “articulate, classy and spectacularly beautiful ” as you has been unable to find your sugar daddy. I find it hard to believe that if you are as gorgeous as you say you are that the $500K hasn’t found you, if not only for a tryout. By the way, you could always find a way to make your own money and then we wouldn’t need to have this difficult conversation. With all that said, I must say you’re going about it the right way. Classic “pump and dump.” I hope this is helpful, and if you want to enter into some sort of lease, let me know.<br>　　<br>　　<br>　　<br>　　Rob Campbell (注：JP摩根的多种产业投资顾问 罗波坎 贝尔)<br>　　<br>　　J.P.Morgan<br>　　<br>　　Diversified Industrials Investment Banking<br>　　<br>　　277 Park Avenue, 16/F, New York, NY 10172 </p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 情感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原生JS实现JQuery链式调用</title>
      <link href="/blog/2019/08/02/%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0JQuery%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/"/>
      <url>/blog/2019/08/02/%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0JQuery%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>用过Jquery的朋友应该都体会过他的链式调用的强大，实现多个功能只需要链式调用方法即可实现，方便而简洁，这篇博客就介绍一下实现链式调用的方式，这里我会讲不止一种书写方式，希望大家可以根据其中的差异学到其精髓</p></blockquote><h2 id="jquery链式调用实现一"><a href="#jquery链式调用实现一" class="headerlink" title="jquery链式调用实现一"></a>jquery链式调用实现一</h2><p>先让我们来看一下jquery链式调用是怎么写的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;.box&quot;</span>).addClass(<span class="string">&quot;ball1&quot;</span>).addClass(<span class="string">&quot;ball2&quot;</span>).removeClass(<span class="string">&quot;.ball1&quot;</span>);</span><br><span class="line"><span class="comment">// 以上功能找到类名为 box 的元素添加一个类名 ball1 &gt; 添加一个类名 ball2 &gt; 添加删除一个类名 ball1</span></span><br></pre></td></tr></table></figure><p><strong>分析：从上面的代码我们不难看出实现jquery链式调用的本质是每一个方法都返回一个对象，这个对象包含特定属性和所有对象共有的方法</strong></p><p>根据上面的分析我们先来实现 $ 获取元素对象集合的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $ 方法的作用是获取dom元素集合，这里我们不能够知道会获取一个还是多个dom，所以要统一就要一律使用集合</span></span><br><span class="line"><span class="built_in">window</span>.$ = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> doms = <span class="built_in">document</span>.querySelectorAll(selector); <span class="comment">// 获取 DOM 集合这是一个类数组</span></span><br><span class="line">    <span class="keyword">var</span> domsArr = <span class="built_in">Array</span>.prototype.slice.call(doms,<span class="number">0</span>); <span class="comment">// 将类数组装换成数组</span></span><br><span class="line">    <span class="keyword">return</span> domsArr; <span class="comment">// 返回这个 dom 集合数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经实现了一个 $ 方法，这个方法返回的是一个数组，数组说白了也是一个对象，是对象就可以绑定属性和方法，我们之前说过每一个方法都要返回相同或者类似的对象才能实现链式调用，那么这 $ 方法返回的这个数组实例是需要包含所有的jquery方法的，那么这些方法要放在哪里才能让所有的数组实例都能访问到呢？</p><p>这个问题如果对javascript面向对象还算了解的同学应该能脱口而出：原型对象！</p><p>现在我们来实现一个 addClass 方法和 removeClass 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 addClass 方法</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.addClass = <span class="function"><span class="keyword">function</span>(<span class="params">className</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.forEach(<span class="function"><span class="params">dom</span> =&gt;</span> &#123;</span><br><span class="line">        dom.classList.add(className);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 removeClass 方法</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.removeClass = <span class="function"><span class="keyword">function</span>(<span class="params">className</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.forEach(<span class="function"><span class="params">dom</span> =&gt;</span> &#123;</span><br><span class="line">        dom.classList.remove(className);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jquery-链式调用实现二"><a href="#jquery-链式调用实现二" class="headerlink" title="jquery 链式调用实现二"></a>jquery 链式调用实现二</h2><p>可以看到第一种实现的方式通过在原生数组对象的原型对象上添加方法来实现链式调用，功能我们的确是实现了，但是他有几个缺点，一个是通常来讲我们不建议在系统对象的原型上做修改，这样容易导致不可控的情况出现；第二就是jquery本身没有一个对象类型，这在做类型判断的时候是不好的，结构上所有的功能都寄生在原生数组对象上；</p><p>那么现在我们要做的就是使用一个专门的 jquery 对象作为每个方法的返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.$ = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> doms = <span class="built_in">document</span>.querySelectorAll(selector); <span class="comment">// 获取 DOM 集合这是一个类数组</span></span><br><span class="line">    <span class="keyword">var</span> domsArr = <span class="built_in">Array</span>.prototype.slice.call(doms,<span class="number">0</span>); <span class="comment">// 将类数组装换成数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Jquery(domsArr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来创建 JQuery 类型对象的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Jquery</span>(<span class="params">domsArr</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.domsArr = domsArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向对象中添加方法</span></span><br><span class="line"><span class="comment">// 实现 addClass 方法</span></span><br><span class="line">Jquery.prototype.addClass = <span class="function"><span class="keyword">function</span>(<span class="params">className</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.domsArr.forEach(<span class="function"><span class="params">dom</span> =&gt;</span> &#123;</span><br><span class="line">        dom.classList.add(className);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 removeClass 方法</span></span><br><span class="line">Jquery.prototype.removeClass = <span class="function"><span class="keyword">function</span>(<span class="params">className</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.domsArr.forEach(<span class="function"><span class="params">dom</span> =&gt;</span> &#123;</span><br><span class="line">        dom.classList.remove(className);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> jquery </tag>
            
            <tag> 链式调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart中的数据类型</title>
      <link href="/blog/2019/07/23/Dart%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/blog/2019/07/23/Dart%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Dart中的数据类型"><a href="#Dart中的数据类型" class="headerlink" title="Dart中的数据类型"></a>Dart中的数据类型</h1><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><p><strong>变量</strong></p><ul><li>使用 var 声明变量，可赋予不同类型的值</li><li>未初始化的变量，默认值为 null</li><li>使用 final 可以声明只能赋值一次的变量</li></ul><p><strong>常量</strong></p><ul><li>const 可以用来声明常量</li><li>使用 const 声明的必须是编译期的常量</li></ul><h2 id="数值类型-Number"><a href="#数值类型-Number" class="headerlink" title="数值类型 Number"></a>数值类型 Number</h2><p>数值型变量通过以下方式定义：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">    <span class="built_in">num</span> a = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// num 类型的变量可以在定义整型之后改为浮点型</span></span><br><span class="line">    a = <span class="number">8.8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> b = <span class="number">9</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">double</span> c = <span class="number">1.2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指定整型或者浮点型以后不可以接受其他类型的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运算符</strong></p><p>+ - * / ~/(取整) %</p><p><strong>常用属性</strong></p><ul><li>isNaN 是否是非数字</li><li>isEven 是否是奇数</li><li>isOdd 是否是偶数</li></ul><p><strong>常用方法</strong></p><ul><li>abs() 取绝对值</li><li>round() 四舍五入</li><li>floor() 向下取整</li><li>ceil() 向上取整</li><li>toInt() 转成整型</li><li>toDouble() 转成浮点型</li></ul><h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 String"></a>字符串 String</h2><p><strong>创建字符串</strong></p><ul><li>单引号，双引号创建</li><li>三引号，双引号创建多行字符串</li><li>使用 r 创建原始 raw 字符串 (会保留字符串中的转义字符)</li><li>插值表达式 ${变量}</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> str1 = <span class="string">&quot;字符串1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> str2 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    换行字符串</span></span><br><span class="line"><span class="string">    第二行</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> str3 = <span class="string">r&quot;原始 \n 字符串&quot;</span>;</span><br><span class="line"><span class="comment">// 另 + 可以拼接字符串 * 可以复制字符串 [] 取字符 == 判断相等</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;插值表达式 <span class="subst">$&#123;str1&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>字符串属性</strong></p><ul><li>length 长度</li><li>isEmpty 是否为空</li></ul><p><strong>字符串方法</strong></p><ul><li>contains() 是否包含</li><li>subString(startIndex,endIndex) 截取字符串 包含 startIndex 不包含 endIndex</li><li>startsWidth() ，endsWidth() 是否以什么开始或者结尾</li><li>indexOf() , lastIndexOf() 查找字符索引位置</li><li>toLowerCase() , toUpperCase() 转大小写</li><li>trim() , trimLeft() , trimRight() 去掉空格</li><li>split() , replaceAll() 切割替换</li></ul><h2 id="数组-List"><a href="#数组-List" class="headerlink" title="数组 List"></a>数组 List</h2><p><strong>创建数组</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list中的元素是可以不同的，访问值可以通过 [] 这种方式还能设置值</span></span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">const</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">// 创建一个不可变List</span></span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> <span class="built_in">List</span>();</span><br></pre></td></tr></table></figure><p><strong>数组方法</strong></p><ul><li>add() insert(位置，值) 添加 插入值</li><li>remove(值) clear() 删除 清空</li><li>indexOf() lastIndexOf()</li><li>sort() sublist() 排序 获取子元素</li><li>shuffle() asMap() forEach() 打乱数组 转Map 遍历</li></ul><h2 id="键值对-Map"><a href="#键值对-Map" class="headerlink" title="键值对 Map"></a>键值对 Map</h2><p><strong>创建map</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">    name: <span class="string">&quot;Autumn&quot;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 声明不可变 map</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">const</span> &#123;</span><br><span class="line">    name: <span class="string">&quot;小华&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取元素 设置元素</span></span><br><span class="line">p[<span class="string">&quot;name&quot;</span>]</span><br></pre></td></tr></table></figure><p><strong>常用操作</strong></p><ul><li>isEmpty() isNotEmpty() 是否为空</li><li>keys values 所有的键或者值</li><li>containsKey() containsValue() 是否包含键或者值</li><li>remove(键) 删除</li><li>forEach() 遍历</li></ul><h2 id="动态类型-dynamic"><a href="#动态类型-dynamic" class="headerlink" title="动态类型 dynamic"></a>动态类型 dynamic</h2><p>dynamic 可以定义一个动态类型</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> s = <span class="number">123</span>;</span><br><span class="line">s = <span class="string">&quot;lalal&quot;</span>;</span><br></pre></td></tr></table></figure><p>该类类型可以应用于泛型中</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个可以装任意类型数据的列表</span></span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">dynamic</span>&gt;();</span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line">list.add(<span class="string">&quot;hahah&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Grid网格布局</title>
      <link href="/blog/2019/07/21/Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/"/>
      <url>/blog/2019/07/21/Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Grid-网格布局"><a href="#Grid-网格布局" class="headerlink" title="Grid 网格布局"></a>Grid 网格布局</h1><blockquote><p> <strong>总体概括</strong><br> Flexbox（弹性盒）用于一维布局 — 也就是行或者列</p><p> 网格用于二维布局 — 也就是多行多列</p></blockquote><h2 id="网格线"><a href="#网格线" class="headerlink" title="网格线"></a>网格线</h2><p>网格线是用来在水平和垂直方分割网格的线。水平方向的网格线是从左向右；垂直方向是从上往下；网格线的序号都是从 1 开始的。</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/example-grid-lines.svg" alt="图片内容"></p><h2 id="网格容器上的属性"><a href="#网格容器上的属性" class="headerlink" title="网格容器上的属性"></a>网格容器上的属性</h2><p>grid-template-colums</p><p>描述：根据值得个数决定网格有多少列，每个值决定对应网格列的宽度</p><p>属性值:</p><ul><li>若干个以空格分割的长度值、百分比、fr</li><li>subgrid 如果你的网格容器本身就是一个网格项，可以使用该值指定行和列大小继承与父元素</li></ul><p>grid-template-rows</p><p>描述：根据值的个数决定网格有多少行，每个值决定对应网格行的高度</p><ul><li>若干个以空格分割的长度值、百分比、fr</li><li>subgrid 如果你的网格容器本身就是一个网格项，可以使用该值指定行和列大小继承与父元素</li></ul><p>grid-template-areas</p><p>描述：使用 grid-area 属性定义网格区域名称，从而定义网格模板。网格区域重复的名称就会导致内容跨越这些单元格。句点表示一个空单元格。语法本身提供了一种可视化的网格结构。</p><p>属性值：</p><ul><li><strong><grid-area-name></strong>: 使用<code>grid-area</code>属性定义的网格区域名称</li><li>. : 句点表示一个空的单元格</li><li>none : 无网格区域被定义</li></ul><p>grid-column-gap 和 grid-row-gap</p><p>描述：指定网格线的大小，你可以吧他想象成在 行/列 之间的间距</p><p>属性值：长度值</p><p>注意：间距只在 行/列 之间产生，不会再边缘区</p><p>grid-gap</p><p>描述：grid-column-gap 和 grid-row-gap 的简写</p><p>属性值：以空格分割的长度值</p><p>justify-items</p><p>描述：沿列轴对齐网格项目中的内容（水平对齐）；适用于网格容器</p><p>属性值：</p><ul><li><strong>start</strong>: 内容与网格区域的左端对齐</li><li><strong>end</strong>: 内容与网格区域的右端对齐</li><li><strong>center</strong>: 内容处于网格区域的中间位置</li><li><strong>stretch</strong>: 内容宽度占据整个网格区域空间(默认值)</li></ul><p>补充：也可以使用 justify-self 属性对单个的网格项目进行设置</p><p>align-items</p><p>描述：垂直对齐；适用于网格容器</p><p>属性值：</p><ul><li><strong>start</strong>: 内容与网格区域的顶端对齐</li><li><strong>end</strong>: 内容与网格区域的底部对齐</li><li><strong>center</strong>: 内容处于网格区域的中间位置</li><li><strong>stretch</strong>: 内容高度占据整个网格区域空间(默认值)</li></ul><p>补充：也可以使用 align-self 属性对单个网格项目对齐</p><p>justify-content</p><p>描述：当你使用<code>px</code>这种非响应式的单位对你的网格项进行大小设置时，就有可能出现一种情况–你的网格大小可能小于其网格容器的大小。在这种情况下，你就可以设置网格容器内网格的对齐方式。此属性会将网格沿列轴进行对齐(相反于<code>align-content</code>属性定义的沿行轴对齐)。非响应式的水平对齐</p><p>属性值：</p><ul><li><strong>start</strong>: 网格与网格容器的左端对齐</li><li><strong>end</strong>: 网格与网格容器的右端对齐</li><li><strong>center</strong>: 网格处于网格容器的中间</li><li><strong>stretch</strong>: 调整网格项的大小，使其宽度填充整个网格容器</li><li><strong>space-around</strong>: 在网格项之间设置偶数个空格间隙，其最边缘间隙大小为中间空格间隙大小的一半</li><li><strong>space-between</strong>: 在网格项之间设置偶数个空格间隙，其最边缘不存在空格间隙</li><li><strong>space-evenly</strong>: 在网格项之间设置偶数个空格间隙，同样适用于最边缘区域</li></ul><p>align-content</p><p>描述：当你使用<code>px</code>这种非响应式的单位对你的网格项进行大小设置时，就有可能出现一种情况–你的网格大小可能小于其网格容器的大小。在这种情况下，你就可以设置网格容器内网格的对齐方式。此属性会将网格沿行轴进行对齐(相反于<code>justify-content</code>属性定义的沿列轴对齐)。非响应式垂直对齐。</p><p>属性值：</p><ul><li><strong>start</strong>: 网格与网格容器的顶端对齐</li><li><strong>end</strong>: 网格与网格容器的底部对齐</li><li><strong>center</strong>: 网格处于网格容器的中间</li><li><strong>stretch</strong>: 调整网格项的大小，使其高度填充整个网格容器</li><li><strong>space-around</strong>: 在网格项之间设置偶数个空格间隙，其最边缘间隙大小为中间空格空隙大小的一半</li><li><strong>space-between</strong>: 在网格项之间设置偶数个空格间隙，其最边缘不存在空格间隙</li><li><strong>space-evenly</strong>: 在网格项之间设置偶数个空格间隙，同样适用于最边缘区域</li></ul><p>grid-auto-columns 和 grid-auto-rows</p><p>描述：指定任何自动生成的网格轨道(隐式网格跟踪)的大小。当你显式定位行或列(使用 <code>grid-template-rows</code>/<code>grid-template-columns</code>属性)时,就会产生超出定义范围内的隐式网格轨道。</p><p>属性值：长度值、百分比、fr</p><p>grid-auto-flow</p><p>描述：如果你不显式的在网格中放置网格项，自动布局算法就会自动踢出此网格项。此属性用来控制自动布局算法的工作原理。</p><p>属性值：</p><ul><li><strong>row</strong>: 告诉自动布局算法填充每一行，必要时添加新行（默认：以填充行为准）</li><li><strong>column</strong>: 告诉自动布局算法填充每一列，必要时添加新列（以填充列为准）</li><li><strong>dense</strong>: 告诉自动布局算法试图填补网格中之前较小的网格项留有的空白</li></ul><p><strong>注意</strong>:<strong>dense</strong>值可能会导致更改网格项的顺序。</p><p>grid</p><p>描述：在一行声明中设置一下所有属性的简写形式:<code>grid-template-rows</code>, <code>grid-template-columns</code>, <code>grid-template-areas</code>, <code>grid-auto-rows</code>, <code>grid-auto-columns</code>, 以及 <code>grid-auto-flow</code>。它将 <code>grid-column-gap</code> 和 <code>grid-row-gap</code>属性设置为初始值，即使它们不能显示的设置此属性。</p><p>属性值：</p><ul><li><strong>none</strong>: 将所有的子属性设置为初始值</li><li><strong>subgrid</strong>: 将<code>grid-template-rows</code> 和 <code>grid-template-columns</code>属性值设置为<code>subgrid</code>,其余子属性设置为初始值</li><li><strong><grid-template-rows></strong> / <strong><grid-template-columns></strong>: 将<code>grid-template-rows</code> 和 <code>grid-template-columns</code>属性值设置为指定值，其余子属性设置为初始值</li><li><strong><grid-auto-flow>[<grid-auto-rows> [ / <grid-auto-columns>] ]</strong> : <code>grid-auto-flow</code>, <code>grid-auto-rows</code> 和 <code>grid-auto-columns</code>属性分别接受相同的值,如果省略了<code>grid-auto-columns</code>属性，它将设置为<code>grid-auto-rows</code>属性的值。如果两者均被忽略，那么都将被设置为初始值。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 等效代码块1</span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">grid</span>: <span class="number">200px</span> auto / <span class="number">1</span>fr auto <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">200px</span> auto;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr auto <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等效代码块2</span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">grid</span>: column <span class="number">1</span>fr / auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">grid-auto-flow</span>: column;</span><br><span class="line">    <span class="attribute">grid-auto-rows</span>: <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-auto-columns</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等效代码块3</span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">grid</span>: [row1-start] <span class="string">&quot;header header header&quot;</span> <span class="number">1</span>fr [row1-end]</span><br><span class="line">          [row2-start] <span class="string">&quot;footer footer footer&quot;</span> <span class="number">25px</span> [row2-end]</span><br><span class="line">          / auto <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>: <span class="string">&quot;header header header&quot;</span></span><br><span class="line">                         <span class="string">&quot;footer footer footer&quot;</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: [row1-start] <span class="number">1</span>fr [row1-end row2-start] <span class="number">25px</span> [row2-end];</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: auto <span class="number">50px</span> auto;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加在网格项上的属性"><a href="#加在网格项上的属性" class="headerlink" title="加在网格项上的属性"></a>加在网格项上的属性</h2><p><a href="https://drafts.csswg.org/css-grid/#propdef-grid-column-start"><strong>grid-column-start</strong></a>：设置网格项目垂直方向的开始位置网格线</p><p><a href="https://drafts.csswg.org/css-grid/#propdef-grid-column-end"><strong>grid-column-end</strong></a>：设置网格项目垂直方向的结束位置网格线</p><p><a href="https://drafts.csswg.org/css-grid/#propdef-grid-row-start"><strong>grid-row-start</strong></a>：设置网格项目水平方向的开始位置网格线</p><p><a href="https://drafts.csswg.org/css-grid/#propdef-grid-row-end"><strong>grid-row-end</strong></a>：设置网格项目水平方向的结束位置网格线</p><p>注意：以上属性的初始值都是 auto</p><p>属性值：</p><ul><li><strong><line></strong>: 可以是一个数字来引用相应编号的网格线，或者使用名称引用相应命名的网格线</li><li><strong>span <number></strong>: 网格项包含指定数量的网格轨道</li><li><strong>span <name></strong>: 网格项包含指定名称网格项的网格线之前的网格轨道</li><li><strong>auto</strong>: 表明自动定位，自动跨度或者默认跨度之一</li></ul><p><strong>网格项目属性的缩写</strong></p><p><a href="https://drafts.csswg.org/css-grid/#propdef-grid-column"><strong>grid-column</strong></a>：是<code>grid-column-start</code>和<code>grid-column-end</code>两个属性的缩写方式</p><p><a href="https://drafts.csswg.org/css-grid/#propdef-grid-row"><strong>grid-row</strong></a>：是<code>grid-row-start</code>和<code>grid-row-end</code>两个属性的缩写方式</p><p><a href="https://drafts.csswg.org/css-grid/#propdef-grid-area"><strong>grid-area</strong></a>：是这四个属性的缩写方式<code>grid-row-start / grid-column-start/ grid-row-end / grid-column-end</code>。</p><p>给网格项进行命名以便于模板使用<code>grid-template-areas</code>属性创建时可以加以引用。另外也可以被<code>grid-row-start</code> + <code>grid-column-start</code> + <code>grid-row-end</code> + <code>grid-column-end</code>属性更为简洁的加以引用。</p><blockquote><p><strong>特别声明</strong>：<code>grid-row</code>、<code>grid-column</code>和<code>grid-area</code>采用缩写时，前后两个值之间需要使用<code>/</code>分割线分开（<code>/</code>分割线之间最好添加一个空格号）。</p></blockquote><p>justify-self</p><p>描述：水平对齐网格项</p><p>属性值：</p><ul><li><strong>start</strong>: 内容与网格区域的左端对齐</li><li><strong>end</strong>: 内容与网格区域的右端对齐</li><li><strong>center</strong>: 内容处于网格区域的中间位置</li><li><strong>stretch</strong>: 内容宽度占据整个网格区域空间(默认值)</li></ul><p>align-self</p><p>描述：垂直对齐</p><p>属性值：</p><ul><li><strong>start</strong>: 内容与网格区域的顶端对齐</li><li><strong>end</strong>: 内容与网格区域的底部对齐</li><li><strong>center</strong>: 内容处于网格区域的中间位置</li><li><strong>stretch</strong>: 内容高度占据整个网格区域空间(默认值)</li></ul><h2 id="单元格跨越（合并单元格）"><a href="#单元格跨越（合并单元格）" class="headerlink" title="单元格跨越（合并单元格）"></a>单元格跨越（合并单元格）</h2><p>span 关键词可以实现但单元格的跨越</p><p>两个等价的写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// span 关键字写法</span><br><span class="line"><span class="selector-class">.item-2</span>&#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">2</span> / span <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 之前的写法</span><br><span class="line"><span class="selector-class">.item-2</span>&#123;</span><br><span class="line">  <span class="attribute">grid-colums</span>: <span class="number">2</span> / <span class="number">4</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/example-grid-lines-item-span.svg"></p><p>注意：你会发现 grid-row 并没有设置 grid-row-end 的网格线。这意味着其值为 auto，自动默认为 span 的值为 1</p><p><strong>负的网格线序号</strong></p><p>负的网格线序号会从 -1 开始反方向计算，如下图</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/example-grid-lines-3.png"></p><p>网格线序列为负值，在某些情况下是有用的，例如，想让某个网格项目始终在最后一列，这个时候只需要设置 grid-column-end : -1</p><h2 id="网格线命名"><a href="#网格线命名" class="headerlink" title="网格线命名"></a>网格线命名</h2><p>网格线除了使用数字来表示之外，还可以给每条网格线命名</p><p>在定义网格的时候，除了设置网格轨道大小之外，在此基础上增加网格线的命名，如下示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.grid-1</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [start] <span class="number">300px</span> [main] <span class="number">200px</span> [aside] <span class="number">100px</span> [end];</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: [top] <span class="number">100px</span> [middle] <span class="number">50px</span> [bottom];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: main / end; </span><br><span class="line">  <span class="attribute">grid-row</span>: top / middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述代码命名演示，有如下图的描述</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/example-grid-lines-item-named.svg"></p><p>其实一条网格线可以有多个名字，如下示例代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-attr">[start]</span> 300<span class="selector-tag">px</span> <span class="selector-attr">[main]</span> 200<span class="selector-tag">px</span> <span class="selector-attr">[aside]</span> 100<span class="selector-tag">px</span> <span class="selector-attr">[end]</span>;</span><br><span class="line"><span class="selector-tag">grid-template-rows</span>: <span class="selector-attr">[top start]</span> 100<span class="selector-tag">px</span> <span class="selector-attr">[middle center]</span> 50<span class="selector-tag">px</span> <span class="selector-attr">[bottom end]</span></span><br></pre></td></tr></table></figure><p>网格线还可以重复命名，并且可以使用正负值，下面的示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.grid-1</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [col] <span class="number">200px</span> [gap] <span class="number">50px</span> [col] <span class="number">200px</span> [gap] <span class="number">50px</span> [col] <span class="number">200px</span> [gap];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: col <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-3</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: col <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-4</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: col <span class="number">1</span> / gap <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-5</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: col -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对应网格示例图</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/example-named-grid-lines-items.svg"></p><p>grid-column 一个值的时候表示开始网格线，负数的时候表示倒着数的序列</p><p>补充：span 除了可以跨越网格数，还可以跨越网格线的名称</p><p>规则：跨域的网格线名称结束网格线计数为开始网格线往后计数（不含开始网格线），如果数字超出网格线名称出现的次数，则占据一行的剩下所有列。</p><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-2</span>&#123;</span><br><span class="line">  <span class="attribute">grid-column</span>:col <span class="number">2</span> / span <span class="number">2</span> gap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/example-named-grid-lines-item-span.svg"></p><h2 id="网格区域"><a href="#网格区域" class="headerlink" title="网格区域"></a>网格区域</h2><p>根据之前学习的内容，可以通过网格线构造出网格区域</p><p>HTML:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;grid-1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-4&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-5&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-6&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f5f7f8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.grid-1</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">300px</span> <span class="number">200px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-template-rows: <span class="number">100px</span> <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.grid-1</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.grid-1</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(1) &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#b03532</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.grid-1</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(2) &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#33a8a5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.grid-1</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(3) &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#30997a</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.grid-1</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(4) &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#6a478f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.grid-1</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(5) &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#da6f2b</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.grid-1</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(6) &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#3d8bb1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  grid-<span class="selector-tag">area</span>: <span class="number">1</span> / <span class="number">1</span> / <span class="number">2</span> / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">  grid-<span class="selector-tag">area</span>: <span class="number">2</span> / <span class="number">1</span> / <span class="number">4</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-4</span> &#123;</span><br><span class="line">  grid-<span class="selector-tag">area</span>: <span class="number">2</span> /  <span class="number">3</span> / <span class="number">4</span>  / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-6</span> &#123;</span><br><span class="line">  grid-<span class="selector-tag">area</span>: <span class="number">4</span> / <span class="number">1</span> / <span class="number">5</span> / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外还可以直接定义网格区域，用来放置对应的网格项目</p><p>Grid 布局使用 grid-template-areas 属性来声明，然后使用 grid-area 调用声明好的网格区域名称来放置对应的网格项目。</p><p>HTML:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;grid&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>title<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span>nav<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span>main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aside&quot;</span>&gt;</span>aside<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.grid</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>: </span><br><span class="line">        <span class="string">&#x27;title  title  title  title  aside&#x27;</span></span><br><span class="line">        <span class="string">&#x27;nav    main   main   main   aside&#x27;</span></span><br><span class="line">        <span class="string">&#x27;nav    main   main   main   aside&#x27;</span></span><br><span class="line">        <span class="string">&#x27;footer footer footer footer footer&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.grid</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#b03532</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.grid</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#33a8a5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.grid</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#30997a</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.grid</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(4)</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#6a478f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.grid</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(5)</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#da6f2b</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.title</span>&#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: title;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.nav</span>&#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: nav;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: main;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.aside</span>&#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: aside;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span>&#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: footer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码对应的图像：</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/example-grid-areas.svg"></p><p><strong>网格区域和网格线命名</strong></p><p>网格线的隐名可以创建网格区域，这些隐名使用 -start 和 -end 后缀添加到网格区域名后面，例如：上例中的 title 区域创建了4 条网格线的隐名：</p><ul><li>区域左边的网格线title-start</li><li>区域右边的网格线title-end</li><li>区域顶边的网格线title-start</li><li>区域底边的网格线title-end</li></ul><p>在使用 grid-template-areas 创建网格区域以后，就隐式的声明了网格线名称，反过来，如果在grid-template-coumns 和 grid-template-rows 中使用了隐式的网格线名称也就默认创建了网格区域</p><p>在网格布局中，如果使用了带有后缀的名词命名了网格线，其实就创建了一个隐式的网格区域，示例：</p><p>HTML:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;grid&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>title<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span>nav<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span>main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aside&quot;</span>&gt;</span>aside<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f5f7f8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [title-start nav-start footer-start] <span class="number">100px</span> [main-start nav-end] <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span> [aside-start title-end main-end] <span class="number">100px</span> [aside-end footer-end];</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: [title-start aside-start] <span class="number">100px</span> [nav-start main-start title-end] <span class="number">100px</span> <span class="number">100px</span> [footer-start nav-end main-end aside-end] <span class="number">100px</span> [footer-end];</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.grid</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.grid</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#b03532</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.grid</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#33a8a5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.grid</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#30997a</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.grid</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(4)</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#6a478f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.grid</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(5)</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#da6f2b</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: title;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nav</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: nav;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.aside</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: aside;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: footer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了带后缀的网格线名称也就有了隐式的网格区域，有了网格区域也就自动有了网格线的隐式名，只要有其中一个就可以用任意两种方式设置网格区域，在思维上一般是先规划好网格区域之后才知道网格线的名称。</p><h2 id="网格轨道"><a href="#网格轨道" class="headerlink" title="网格轨道"></a>网格轨道</h2><p>网格轨道其实就是网格的行或列。就是网格中相邻两条网格线组成的区域</p><p>网格中的每个轨道都有一个尺寸函数，用来控制行的高度或列的宽度。而且还具备自动计算的功能，当内容超过网格行、列指定的尺寸时，会自动增加行的高度或列的宽度，相邻网格轨道可以通过网格间距隔开。</p><p><strong>单元格</strong></p><p>网格单元格是指网格行和列交叉点。他是一个定位网格项目时要参考的网格的最小单位</p><p>在网格布局中，多个单元格可以构成一个网格区域。</p><p><strong>声明网格和网格容器</strong></p><p>在CSS中，声明网格主要方式就是通过给某个容器的<code>display</code>设置为<code>grid</code>、<code>inline-grid</code>或者<code>subgrid</code>值之一。同时这个容器就被称为<strong>网格容器</strong>，而这个容器的子元素就称为<strong>网格项目</strong></p><p>网格容器不是块容器(<code>display:block</code>)，因此在块容器中的一些属性使用并不适用于网格容器当中:</p><ul><li>多列布局属性<code>column-*</code>不能用于网格容器</li><li>浮动和清除浮动，对于网格项目中使用不生效。但是，浮动的属性对于网格容器的子元素还是生效的</li><li><code>vertical-align</code>属性对于网格项目不生效</li><li><code>::first-line</code>和<code>::first-letter</code>伪元素不能用于网格容器</li></ul><p>在 Grid 布局中，通过 grid-template-columns 和 grid-template-rows 确定一个网格的列数，、行数以及网格的大小</p><p>grid-template-columns  grid-template-rows grid-template-areas 三个属性可以显示创建一个网格容器，三个属性可以简写成 grid-template </p><p>综合属性的书写方式为： grid-template: rows / columns</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 等价的书写方式</span><br><span class="line">grid-template: auto 1fr / auto 1fr auto;</span><br><span class="line"></span><br><span class="line">// 以上等价于以下</span><br><span class="line"><span class="selector-tag">grid-template-rows</span>: <span class="selector-tag">auto</span> 1<span class="selector-tag">fr</span>;</span><br><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">auto</span> 1<span class="selector-tag">fr</span> <span class="selector-tag">auto</span>;</span><br><span class="line"><span class="selector-tag">grid-template-areas</span>: <span class="selector-tag">none</span>;</span><br><span class="line"></span><br><span class="line">// 三个属性混合书写与等价写法</span><br><span class="line"><span class="selector-tag">grid-template</span>: <span class="selector-attr">[header-top]</span> &quot;<span class="selector-tag">a</span>   <span class="selector-tag">a</span>   <span class="selector-tag">a</span>&quot;     <span class="selector-attr">[header-bottom]</span></span><br><span class="line">             <span class="selector-attr">[main-top]</span> &quot;<span class="selector-tag">b</span>   <span class="selector-tag">b</span>   <span class="selector-tag">b</span>&quot; 1<span class="selector-tag">fr</span> <span class="selector-attr">[main-bottom]</span></span><br><span class="line">                      / auto 1fr auto;</span><br><span class="line">                      </span><br><span class="line"><span class="selector-tag">grid-template-areas</span>: &quot;<span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span>&quot;</span><br><span class="line">                     &quot;<span class="selector-tag">b</span> <span class="selector-tag">b</span> <span class="selector-tag">b</span>&quot;;</span><br><span class="line"><span class="selector-tag">grid-template-rows</span>: <span class="selector-attr">[header-top]</span> <span class="selector-tag">auto</span> <span class="selector-attr">[header-bottom main-top]</span> 1<span class="selector-tag">fr</span> <span class="selector-attr">[main-bottom]</span>;</span><br><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">auto</span> 1<span class="selector-tag">fr</span> <span class="selector-tag">auto</span>;</span><br></pre></td></tr></table></figure><h2 id="隐式网格"><a href="#隐式网格" class="headerlink" title="隐式网格"></a>隐式网格</h2><p>使用 grid-auto-rows 和 grid-auto-columns 可以创建一个隐式网格，隐式单元格不确定列数或行数，具体的列数和行数根据 grid-column 或 grid-row 而定，而显示网格则已经确定行数或列数</p><p>隐式网格就是在使用 grid-template-columns 和 grid-template-rows 的时候可能只定义了1 行 2 列，但是在通过 grid-column 指定网格的位置的时候指定到了第 5 列，此时这是额外增加的网格，该网格宽高则遵循隐式网格的声明，如果没有设置隐式网格那么新增网格宽高会根据剩余空间自动确定</p><p>在没有定义隐式网格新增网格的情况下自适应规则为：在显式网格后追加一个隐式网格默认宽度占据剩余宽度，追加多个隐式网格则隐式网格平分剩余空间，跳过 x 网格数创建的隐式网格和追加多个网格规则一样</p><p>grid-auto-columns 可以给多个以空格分割的长度值，该长度值将被重复应用于后来添加的隐式网格区域</p><p>合并单元格也会创建隐式网格，例如给一行中的最后一个项目设置跨列就会创建隐式的列</p><p>隐式的轨道也可以在显示网格轨道前添加，使用 grid-column 属性的负值就可以做到</p><p><strong>隐式网格和网格线命名</strong></p><p>创建隐式的网格还可以通过使用未定义的网格线名称来创建，在 grid-column 中使用未定义的网格线名称会隐式定义后面网格线都为该网格线名称。示例为一个未定义的 foo 网格线名称</p><p><img src="https://blog-1252270016.cos.ap-chengdu.myqcloud.com/example-implicit-grid-undefined-named-lines.svg"></p><p>网格容器的无效属性:column float clear vertical-align</p><p>repeat()**</p><p>在大量行或列重复的时候，可以使用repeat</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 一个等价写法的示范</span><br><span class="line"><span class="selector-tag">grid-template-columns</span>: 10<span class="selector-tag">px</span> <span class="selector-attr">[col-start]</span> 250<span class="selector-tag">px</span> <span class="selector-attr">[col-end]</span></span><br><span class="line">                       10<span class="selector-tag">px</span> <span class="selector-attr">[col-start]</span> 250<span class="selector-tag">px</span> <span class="selector-attr">[col-end]</span></span><br><span class="line">                       10<span class="selector-tag">px</span> <span class="selector-attr">[col-start]</span> 250<span class="selector-tag">px</span> <span class="selector-attr">[col-end]</span></span><br><span class="line">                       10<span class="selector-tag">px</span> <span class="selector-attr">[col-start]</span> 250<span class="selector-tag">px</span> <span class="selector-attr">[col-end]</span> 10<span class="selector-tag">px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">repeat</span>(4, 10<span class="selector-tag">px</span> <span class="selector-attr">[col-start]</span> 250<span class="selector-tag">px</span> <span class="selector-attr">[col-end]</span>) 10<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><p>repeat() 语法：</p><p>repeat(重复次数, 待重复列表)</p><p><strong>网格间隔</strong></p><p>grid-column-gap 定义列的间隔距离</p><p>grid-row-gap 定义行的间隔距离</p><p>grid-gap 定义行和列的间隔距离</p><p><strong>grid-template</strong> 是 grid-template-rows grid-template-columns grid-template-areas 的简写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-temnplate:auto 1fr &#x2F; auto 1fr auto</span><br></pre></td></tr></table></figure><p>网格重叠与排序</p><p>网格之间可以重叠，层级关系使用 z-index 指定</p><p>网格可以排序，使用 order 指定顺序 </p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网格布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Js块级绑定</title>
      <link href="/blog/2019/07/21/Js%E5%9D%97%E7%BA%A7%E7%BB%91%E5%AE%9A/"/>
      <url>/blog/2019/07/21/Js%E5%9D%97%E7%BA%A7%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="块级声明"><a href="#块级声明" class="headerlink" title="块级声明"></a>块级声明</h1><p>块级作用域在一下情况被创建：</p><ul><li>一个函数内部</li><li>一个代码块</li></ul><p>$let$ 声明与 $var$ 的语法一致，但会将变量的作用域限制在当前代码块中，  $let$ 声明不会提升变量所以需要手动将 $let$ 声明放置在顶部以便让变量在整个代码块内部可用。</p><p>$let$ 声明的特点：</p><ul><li>没有变量提升</li></ul><ul><li>$let$ 不能再当前作用域重复声明任何已有的变量</li></ul><p>$ES6$ 中使用 $const$ 声明常量，常量的值在被设置后不可改变，所以所有的常量需要在声明时进行初始化， $const$ 声明也是块级作用域。</p><p><strong>$js$ 常量如果是一个对象，它所包含的值是可以被修改的（不变的是对象的引用地址）</strong></p><p><strong>$const$ 声明会阻止对于变量绑定与变量自身值得修改，但并不会阻止对变量成员的修改</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name:<span class="string">&quot;Autumn&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">&quot;Other&quot;</span>; <span class="comment">// 可以修改对象中的属性</span></span><br><span class="line"></span><br><span class="line">person = &#123;</span><br><span class="line">  name=<span class="string">&quot;Other&quot;</span>; <span class="comment">// 该操作抛出错误，因为这在修改变量的绑定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>暂时性死区：</strong></p><p>未声明变量之前，任何对变量的访问都将抛出错误，包括对变量使用 $typeof$ 操作符。</p><p><strong>循环內的函数：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  arr.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(i);&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">  func(); <span class="comment">//这里会输出数值“10”十次</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上段代码我们预期的结果是输出 $0-9$ 的数值，但事实并非如此，解决办法是闭包或更简单 $let$ 声明。</p><p><strong>循环内的常量声明：</strong></p><p>在 $for$ 循环中不可以使用$const$声明，因为在执行 $i++$ 的时候会报错，但是在 $for…in$ 与 $for…of$ 中可以使用。因为循环为每次迭代创建了一个新的变量绑定，而不是去修改已绑定的变量的值。</p><p><strong>全局块级绑定：</strong></p><p>在全局作用域中使用 $var$ 声明可能会覆盖已有的全局属性，而 $let$ 或 $const$ 虽然会在全局作用域上创建新的变量但不会在全局对象绑定该变量，这就意味着不能使用 $let$ 或 $const$ 覆盖全局变量，只能将其屏蔽。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
